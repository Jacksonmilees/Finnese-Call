(function() {
  var FreeSwitchClient, FreeSwitchParser, FreeSwitchResponse, FreeSwitchServer, connectionListener, debug, net, util,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  net = require('net');

  exports.debug = true;

  if (exports.debug) {
    util = require('util');
    debug = function(o) {
      return util.log(util.inspect(o));
    };
  }

  FreeSwitchParser = require('./parser');

  FreeSwitchResponse = require('./response');

  connectionListener = function(call) {
    var parser;
    call.socket.setEncoding('ascii');
    parser = new FreeSwitchParser(call.socket);
    call.socket.on('data', function(data) {
      return parser.on_data(data);
    });
    call.socket.on('end', function() {
      return parser.on_end();
    });
    call.socket.on('CHANNEL_EXECUTE_COMPLETE', function(call) {
      var application, application_data;
      application = call.body['Application'];
      application_data = call.body['Application-Data'];
      return call.socket.emit("CHANNEL_EXECUTE_COMPLETE " + application + " " + application_data, call);
    });
    parser.process = function(headers, body) {
      var error, event, n, _i, _len, _ref;
      if (typeof debug === "function") {
        debug({
          headers: headers,
          body: body
        });
      }
      switch (headers['Content-Type']) {
        case 'auth/request':
          event = 'freeswitch_auth_request';
          break;
        case 'command/reply':
          event = 'freeswitch_command_reply';
          if (headers['Event-Name'] === 'CHANNEL_DATA') {
            body = headers;
            headers = {};
            _ref = ['Content-Type', 'Reply-Text', 'Socket-Mode', 'Control'];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              n = _ref[_i];
              headers[n] = body[n];
              delete body[n];
            }
          }
          break;
        case 'text/event-json':
          try {
            body = JSON.parse(body);
          } catch (_error) {
            error = _error;
            if (typeof debug === "function") {
              debug("JSON " + error + " in " + body);
            }
            return;
          }
          event = body['Event-Name'];
          break;
        case 'text/event-plain':
          body = parse_header_text(body);
          event = body['Event-Name'];
          break;
        case 'log/data':
          event = 'freeswitch_log_data';
          break;
        case 'text/disconnect-notice':
          event = 'freeswitch_disconnect_notice';
          break;
        case 'api/response':
          event = 'freeswitch_api_response';
          break;
        default:
          event = headers['Content-Type'];
      }
      call.headers = headers;
      call.body = body;
      if (typeof debug === "function") {
        debug({
          when: 'connection listener socket.emit',
          event: event,
          call: call
        });
      }
      return call.socket.emit(event, call);
    };
    if (typeof debug === "function") {
      debug({
        when: 'connection listener emit freeswitch_connect',
        call: call
      });
    }
    return call.socket.emit('freeswitch_connect', call);
  };

  FreeSwitchServer = (function(_super) {
    __extends(FreeSwitchServer, _super);

    function FreeSwitchServer(requestListener) {
      this.on('connection', function(socket) {
        socket.on('freeswitch_connect', requestListener);
        return connectionListener(new FreeSwitchResponse(socket));
      });
      FreeSwitchServer.__super__.constructor.call(this);
    }

    return FreeSwitchServer;

  })(net.Server);

  exports.server = function(handler) {
    var server;
    server = new FreeSwitchServer(function(call) {
      var Unique_ID;
      Unique_ID = 'Unique-ID';
      return call.sequence([
        function() {
          return this.connect();
        }, function() {
          this.command('verbose_events');
          return this.auto_cleanup();
        }, function() {
          var unique_id;
          unique_id = this.body[Unique_ID];
          return this.filter(Unique_ID, unique_id);
        }, function() {
          return this.event_json('ALL');
        }, function() {
          return typeof handler === "function" ? handler(this) : void 0;
        }
      ]);
    });
    return server;
  };

  FreeSwitchClient = (function(_super) {
    __extends(FreeSwitchClient, _super);

    function FreeSwitchClient() {
      this.on('connect', function() {
        return connectionListener(new FreeSwitchResponse(this));
      });
      FreeSwitchClient.__super__.constructor.call(this);
    }

    return FreeSwitchClient;

  })(net.Socket);

  exports.client = function(options, handler) {
    var client, _ref;
    if (options == null) {
      options = {};
    }
    if (typeof options === 'function') {
      _ref = [{}, options], options = _ref[0], handler = _ref[1];
    }
    if (options.password == null) {
      options.password = 'ClueCon';
    }
    if (handler == null) {
      throw new Error("handler is required");
    }
    client = new FreeSwitchClient();
    client.once('freeswitch_auth_request', function(call) {
      if (typeof debug === "function") {
        debug({
          when: "Challenged for authentication"
        });
      }
      return call.auth(options.password).then(function(call) {
        call.auto_cleanup();
        if (typeof debug === "function") {
          debug({
            when: "Authentication sent",
            call: call
          });
        }
        return typeof handler === "function" ? handler(call) : void 0;
      });
    });
    return client;
  };

}).call(this);
